import java.util.*;
class Solution {
    private List<List<Integer>> adjList = new ArrayList<>(); 
    private int currentNodeCount = 0; // 현재 탐색 중인 서브 그래프 노드 수
    private int currentEdgeCount = 0; // 현재 탐색 중인 서브 그래프 엣지 수
    
    public int[] solution(int[][] edges) {
        int[] answer = new int[4];
        
        // 그래프의 최대 노드 번호 찾기
        int maxNodeNum = 0;
        for (int[] edge : edges) {
            maxNodeNum = Math.max(maxNodeNum, edge[0]);
            maxNodeNum = Math.max(maxNodeNum, edge[1]);
        }
        
        // 그래프 초기화
        int[] inDegree = new int[maxNodeNum + 1];
        int[] outDegree = new int[maxNodeNum + 1];
        
        for (int i = 0; i <= maxNodeNum; i++) adjList.add(new ArrayList<>());
        
        for (int[] edge : edges) {
            int from = edge[0];
            int to = edge[1];
            adjList.get(from).add(to);
            outDegree[from]++;
            inDegree[to]++;
        }
        
        // 1st 생성된 노드 찾기 (진입차수 0, 진출차수 2 이상)
        int generatedNode = 0;
        for (int i = 1; i <= maxNodeNum; i++) {
            if (inDegree[i] == 0 && outDegree[i] >= 2) {
                generatedNode = i;
                break;
            }
        }

        answer[0] = generatedNode;
        
        // 2nd 생성된 노드에서 시작하는 각 서브그래프 종류 판별
        List<Integer> entryNodes = adjList.get(generatedNode);
        for (int entryNode : entryNodes) {
            // 탐색 전 카운트 초기화
            currentNodeCount = 0;
            currentEdgeCount = 0;
            
            // 서브 그래프 탐색 
            dfs(entryNode, new boolean[maxNodeNum + 1], outDegree);
            
            // 그래프 종류 판별
            if (currentEdgeCount == currentNodeCount) {
                answer[1]++; // 도넛 모양
            } else if (currentEdgeCount == currentNodeCount - 1) {
                answer[2]++; // 막대 모양
            } else {
                answer[3]++; // 8자 모양
            }
        }
        
        return answer;
    }
   
    // 서브그래프 탐색 for 노드 & 간선 수 계산
    private void dfs(int currentNode, boolean[] visited, int[] outDegree) {
        visited[currentNode] = true;
        currentNodeCount++;
        currentEdgeCount += outDegree[currentNode]; // 정점의 진출차수 합 = 간선 수
        
        List<Integer> neighbors = adjList.get(currentNode);
        for (int nextNode : neighbors) {
            if (!visited[nextNode]) {
                dfs(nextNode, visited, outDegree);
            }
        }
    }
}
