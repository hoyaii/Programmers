class Solution {
    public int[] solution(long[] numbers) {
        int[] answer = new int[numbers.length];
        for (int i = 0; i < numbers.length; i++) {
            answer[i] = isRepresentable(numbers[i]) ? 1 : 0;
        }

        return answer;
    }

    private boolean isRepresentable(long num) {
        String binaryString = Long.toBinaryString(num);
        int len = binaryString.length();

        // 포화 이진 트리의 문자열 형식으로 만들기 위해 패딩 길이 구하기 (포화 이진 트리의 문자 길이는 2^n-1)
        int treeHeight = 1;
        int totalNodes = 1;
        while (totalNodes < len) {
            treeHeight++;
            totalNodes = (int) Math.pow(2, treeHeight) - 1;
        }

        // 패딩을 붙여서 포화 이진 트리 문자열 형식 완성!
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < totalNodes - len; i++) sb.append('0');
        sb.append(binaryString);
        
        return validateSubtree(sb.toString());
    }

    // 재귀를 통해 자식은 1인데 부모가 0인 케이스 체크
    private boolean validateSubtree(String binary) {
        // 노드가 하나면 유효
        if (binary.length() <= 1) return true;

        int mid = binary.length() / 2;
        char root = binary.charAt(mid);
        String leftSubtree = binary.substring(0, mid);
        String rightSubtree = binary.substring(mid + 1);

        // 부모가 '0'인데 자식 노드가 '1'이면 규칙 위반
        if (root == '0' && (leftSubtree.charAt(leftSubtree.length() / 2) == '1' 
                         || rightSubtree.charAt(rightSubtree.length() / 2) == '1')) {
            return false;
        }

        // 왼쪽과 오른쪽 서브트리도 체크
        return validateSubtree(leftSubtree) && validateSubtree(rightSubtree);
    }
}
​
