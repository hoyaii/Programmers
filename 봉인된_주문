import java.util.Arrays;
class Solution {
    public String solution(long n, String[] bans) {
        // 금지된 주문들을 숫자 인덱스로 변환하고 정렬
        long[] bannedIndices = new long[bans.length];
        for (int i = 0; i < bans.length; i++) {
            bannedIndices[i] = convertToNumber(bans[i]);
        }
        Arrays.sort(bannedIndices);

        // n 이하의 금지된 주문 개수를 카운팅 
        int pushesNeeded = 0;
        for (long bannedIndex : bannedIndices) {
            if (bannedIndex <= n) {
                pushesNeeded++;
            } else { // 배열이 정렬되어 있으므로, n보다 큰 값을 만나면 더 이상 볼 필요가 없음
                break;
            }
        }

        // n에서 시작하여, 필요한 이동 횟수(pushesNeeded)만큼 인덱스를 뒤로 미룸
        long finalIndex = n;
        while (pushesNeeded > 0) {
            finalIndex++;

            // 현재 인덱스가 금지되었는지 확인 -> 금지되었다면 이동 횟수를 줄이지 않고 다음 인덱스로!
            if (Arrays.binarySearch(bannedIndices, finalIndex) >= 0) {
                continue;
            }

            // 유효한 위치를 찾았으므로 이동 횟수를 차감
            pushesNeeded--;
        }

        // 최종 인덱스를 다시 문자열로 변환해 반환
        return convertToString(finalIndex);
    }

    // 주문 문자열을 고유한 숫자 인덱스로 변환 ("a" -> 1, "z" -> 26 등)
    private long convertToNumber(String s) {
        long value = 0L;
        for (char c : s.toCharArray()) {
            value *= 26L;
            value = (c - 'a' + 1);
        }

        return value;
    }

    // 숫자 인덱스를 다시 문자열로 변환
    private String convertToString(long value) {
        StringBuilder sb = new StringBuilder();
        while (val > 0) {
            // val을 1-based에서 0-based로 잠시 변환
            val--; 
            sb.append((char) ('a' + (val % 26)));
            val /= 26;
        }
        return sb.reverse().toString();
    }
}
