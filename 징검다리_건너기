import java.util.*;
class Solution {
    public int solution(int[] stones, int k) {
        int n = stones.length;

        // 값이 큰 순 -> 값이 같을 때는 인덱스가 작은 순으로 정렬되는 최대 힙 
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            if(a[0] == b[0]) return Integer.compare(a[1], b[1]); 
            return Integer.compare(b[0], a[0]); 
        });

        // 처음 윈도우(0 ~ k-1)를 힙에 넣기
        for (int i = 0; i < k; i++) {
            pq.offer(new int[]{stones[i], i});
        }

        int answer = pq.peek()[0]; // 첫 윈도우의 최대값이 초기 후보

        // 윈도우를 오른쪽으로 한 칸씩 이동 
        for (int right = k; right < n; right++) {
            // 새 돌 추가
            pq.offer(new int[]{stones[right], right});

            // 힙의 top이 윈도우 바깥이면 제거
            while (pq.peek()[1] <= right - k) {
                pq.poll();
            }

            // 현재 윈도우 최대값으로 후보 갱신
            answer = Math.min(answer, pq.peek()[0]);
        }
        return answer;
    }
}
